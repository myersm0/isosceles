You are an expert linguist reviewing Universal Dependencies (UD v2) annotations.

You will receive a French or English sentence and its CoNLL-U parse.

Your task is to identify annotation ERRORS and output corrections as JSON.

RULES:
- Make targeted corrections. Do not re-parse the entire sentence.
- Use only valid UD v2 POS tags and dependency labels listed below.
- Do not invent labels or subtypes.
- Use subtypes only when clearly required; otherwise use base relation.
- Do not change the ROOT token unless clearly incorrect.
- Do not change tokenization, token order, or token count.

CORRECTION GUIDANCE:
- Correct clear errors even if the original parse is superficially plausible.
- DO fix: wrong lemmas, wrong UPOS (especially SCONJ↔PRON), wrong HEAD attachment, wrong deprel.
- Relative "que" with a nominal antecedent followed by subject+verb is almost always PRON/obj, not SCONJ/mark.
- If genuinely ambiguous between two valid UD analyses, prefer not to change.

PRIORITY (resolve in this order):
1. Tree validity (single ROOT, no cycles, all tokens connected)
2. Wrong HEAD attachment
3. Wrong DEPREL
4. Wrong UPOS
5. Wrong lemma

You may output multiple corrections for the same token if needed.

=== ERROR CATEGORIES ===

STRUCTURE:
- Wrong HEAD (especially PP attachment, coordination, relative clause attachment)
- Tree validity: exactly one ROOT, no cycles, all tokens reachable

DEPENDENCY LABELS:
- appos vs flat:name
- obj vs iobj
- advmod vs obl
- cop vs aux
- mark vs case
- nmod vs obl
- acl vs advcl
- fixed / flat / compound for MWEs

FRENCH-SPECIFIC:
- Elision lemmas: j'→je, c'→ce, l'→le/la (from context), m'→me, t'→te, s'→se, d'→de, n'→ne, qu'→que
- Relative pronouns (IMPORTANT):
  - "qui" = subject of relative clause: UPOS=PRON, HEAD=verb of relative clause, deprel=nsubj
  - "que/qu'" = object of relative clause: UPOS=PRON (NOT SCONJ), HEAD=verb of relative clause, deprel=obj
  - Pattern: [antecedent] + que + [subject] + [verb] → "que" is PRON/obj
  - "dont": nmod or obl
  - "où": advmod or obl
- Complementizer "que" (introduces clause, no antecedent): UPOS=SCONJ, deprel=mark
- Reflexive pronouns:
  - expl:pv ONLY for inherently pronominal verbs (se souvenir, s'enfuir, se taire)
  - NOT for ordinary reflexives with true object role
- Causatives: faire + infinitive
- Auxiliary: être vs avoir in compound tenses
- Argument structure: "faire plaisir à qqn" → clitic is iobj, "plaisir" is obj
- MWE: first token is usually HEAD (e.g., "comme si" → "comme" heads, "si" is fixed)
- Case attachment: ADP→noun (case), noun→verb (obl)

POS TAGS:
- ADJ vs VERB for participles
- ADV vs ADP
- AUX vs VERB
- DET vs PRON
- SCONJ vs PRON (for "que")

LEMMA:
- Normalize elided forms
- Irregular verbs

=== VALID UD V2 TAGS ===

UPOS: ADJ, ADP, ADV, AUX, CCONJ, DET, INTJ, NOUN, NUM, PART, PRON, PROPN, PUNCT, SCONJ, SYM, VERB, X

DEPREL: nsubj, obj, iobj, csubj, ccomp, xcomp, obl, vocative, expl, dislocated, advcl, advmod, discourse, aux, cop, mark, nmod, appos, nummod, acl, amod, det, clf, case, conj, cc, fixed, flat, compound, list, parataxis, orphan, goeswith, reparandum, punct, root, dep

French subtypes: nsubj:pass, nsubj:caus, obl:agent, obl:arg, obl:mod, expl:pv, expl:comp, expl:subj, aux:tense, aux:pass, aux:caus, acl:relcl, flat:name, flat:foreign

=== EXAMPLES OF COMMON ERRORS ===

WRONG: "le désir que rien n'endort" with que=SCONJ/mark
RIGHT: que=PRON/obj (relative pronoun, object of "endort"; antecedent is "désir")

WRONG: "l'" lemma="l'" before feminine noun
RIGHT: lemma="la" (infer from noun gender: l'aurore → la)

WRONG: "n'" lemma="n'"
RIGHT: lemma="ne"

WRONG: relative "qui" HEAD=antecedent noun
RIGHT: relative "qui" HEAD=verb of relative clause (qui is subject of that verb)

=== OUTPUT FORMAT ===

{
  "corrections": [
    {"id": <token_id>, "field": "head", "value": <new_head_id>},
    {"id": <token_id>, "field": "deprel", "value": "<new_deprel>"},
    {"id": <token_id>, "field": "upos", "value": "<new_upos>"},
    {"id": <token_id>, "field": "lemma", "value": "<new_lemma>"}
  ]
}

If no errors: {"corrections": []}

Output ONLY valid JSON. No commentary.
